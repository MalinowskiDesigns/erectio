@use 'sass:map' as map;
@use 'sass:list' as list;

$breakpoints: (
	mobile: 319px,
	tablet: 743px,
	desktop: 1200px,
) !default;

@function bp($name) {
	@if map.has-key($breakpoints, $name) {
		@return map.get($breakpoints, $name);
	}
	@error 'Nieznany breakpoint: `#{$name}`';
}

@mixin respond($point, $type: range) {
	$keys: map.keys($breakpoints);
	$pos: list.index(
		$keys,
		$point
	); // np. index((mobile, tablet, desktop), tablet) = 2

	$value: bp($point);
	$next-key: null;
	// 1) Sprawdźmy, czy taki breakpoint istnieje
	@if not map.has-key($breakpoints, $point) {
		@error 'Nieznany breakpoint: `#{$point}`';
	}
	@if $pos and $pos < list.length($keys) {
		$next-key: list.nth($keys, $pos + 1);
	}

	// 5) Generowanie media-query
	@if $type == min {
		// od $point w górę
		@media (min-width: #{$value}) {
			@content;
		}
	} @else if $type == max {
		// od 0 do $point
		@media (max-width: #{$value}) {
			@content;
		}
	} @else if $type == range {
		// jeśli to MOBILE — od 0 do (tablet - 1px)
		@if $point == mobile {
			$tablet-value: bp(tablet);
			$max-value: $tablet-value - 1px;
			@media (max-width: #{$max-value}) {
				@content;
			}
		} @else if $next-key {
			$next-value: bp($next-key);
			$max-value: $next-value - 1px;
			@media (min-width: #{$value}) and (max-width: #{$max-value}) {
				@content;
			}
		} @else {
			// jeśli $point to ostatni (desktop) — od desktop w górę
			@media (min-width: #{$value}) {
				@content;
			}
		}
	} @else {
		@error 'Drugi parametr mixina `respond` musi być "min", "max" lub "range"';
	}
}

/* 4. Gotowe media-query stringi – wygodne, gdy potrzebujesz inline */
$hover: '(hover: hover) and (pointer: fine)';
$mobile: '(max-width: #{bp(tablet) - 1px})';
$tablet: '(min-width: #{bp(tablet)}) and (max-width: #{bp(desktop) - 1px})';
$desktop: '(min-width: #{bp(desktop)})';
